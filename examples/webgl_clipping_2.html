<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - clipping planes</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="main.css" />
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import Stats from "three/addons/libs/stats.module.js";
			import { GUI } from "three/addons/libs/lil-gui.module.min.js";

			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			let camera, scene, renderer, startTime, object, stats;
            let raycaster, mouse;

			init();
			animate();

			function init() {
				camera = new THREE.PerspectiveCamera(
					36,
					window.innerWidth / window.innerHeight,
					0.25,
					100
				);

				camera.position.set(3, 1.5, 3);
				// camera.lookAt(0,0,0)

				scene = new THREE.Scene();


				// Lights
				scene.add(new THREE.AmbientLight(0xcccccc));
				
				const spotLight = new THREE.SpotLight(0xffffff, 60);
				spotLight.angle = Math.PI / 5;
				spotLight.penumbra = 0.2;
				spotLight.position.set(2, 3, 3);
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 3;
				spotLight.shadow.camera.far = 10;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				scene.add(spotLight);

				const dirLight = new THREE.DirectionalLight(0x55505a, 3);
				dirLight.position.set(0, 3, 0);
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 10;

				dirLight.shadow.camera.right = 1;
				dirLight.shadow.camera.left = -1;
				dirLight.shadow.camera.top = 1;
				dirLight.shadow.camera.bottom = -1;

				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;
				scene.add(dirLight);


				// ***** Clipping planes: *****
				const localPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.8);
				const globalPlane = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 0.1);

				const localPlaneHelper = new THREE.PlaneHelper(localPlane, 1, 0xffffff);
				// scene.add(localPlaneHelper);

				/////////////////////////////////////////////////////////////////////////////////////////////////////
				// Plane size for visualization purposes
				const planeSize = 1;
				const xOffset = 0; // Amount to move the cube along the x-axis
				const yOffset = 0; // Amount to move the cube along the y-axis
				const zOffset = 0; // Amount to move the cube along the z-axis

				// Define the six planes
				const planes = [];

				// Normal vectors and constants for the cube planes
				const planeDefinitions = [
					{normal: new THREE.Vector3(1, 0, 0),    constant: planeSize / 2 + xOffset,}, // Left face
					{normal: new THREE.Vector3(-1, 0, 0),   constant: planeSize / 2 - xOffset,}, // Right face
					{normal: new THREE.Vector3(0, 1, 0),    constant: planeSize / 2 + yOffset,}, // Bottom face
					{normal: new THREE.Vector3(0, -1, 0),   constant: planeSize / 2 - yOffset,}, // Top face
					{normal: new THREE.Vector3(0, 0, 1),    constant: planeSize / 2 + zOffset,}, // Back face
					{normal: new THREE.Vector3(0, 0, -1),   constant: planeSize / 2 - zOffset,}, // Front face
				];

				// Create planes and add helpers to the scene
                const helpers = new THREE.Group();

				planeDefinitions.forEach((def, index) => {
					const plane = new THREE.Plane(def.normal, def.constant);
					const planeHelper = new THREE.PlaneHelper(plane,planeSize,0xff0000);
                    helpers.add(planeHelper);
					planes.push(plane);
				});


				helpers.visible = false;
				scene.add( helpers );
				/////////////////////////////////////////////////////////////////////////////////////////////////////

				// Geometry

				const material = new THREE.MeshPhongMaterial({
					color: 0x80ee10,
					shininess: 100,
					side: THREE.DoubleSide,

					// ***** Clipping setup (material): *****
					// clippingPlanes: [localPlane],
					clippingPlanes: planes,
                    clipIntersection: false,
					clipShadows: true,

					alphaToCoverage: true,
				});

				const geometry = new THREE.TorusKnotGeometry(0.4, 0.08, 95, 20);
				// const geometry = new THREE.PlaneGeometry(1.5, 1.5);

				object = new THREE.Mesh(geometry, material);
				object.castShadow = true;
				scene.add(object);
				// console.log(object.position);
				// object.position.set(-1, 0, 0);

				const axesHelper = new THREE.AxesHelper( 5 );
				scene.add( axesHelper );

				const ground = new THREE.Mesh(
					new THREE.PlaneGeometry(9, 9, 1, 1),
					new THREE.MeshPhongMaterial({ color: 0xa0adaf, shininess: 150 })
				);

				ground.rotation.x = -Math.PI / 2; // rotates X/Y to X/Z
				ground.receiveShadow = true;
				// scene.add(ground);

				// Stats

				stats = new Stats();
				document.body.appendChild(stats.dom);

				// Renderer

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				window.addEventListener("resize", onWindowResize);
				document.body.appendChild(renderer.domElement);

				// ***** Clipping setup (renderer): *****
				const globalPlanes = [globalPlane], Empty = Object.freeze([]);
				renderer.clippingPlanes = Empty; // GUI sets it to globalPlanes
				renderer.localClippingEnabled = true;


				// Controls
				const controls = new OrbitControls(camera, renderer.domElement);
				controls.target.set(0, 0, 0);
				controls.update();


				// GUI
				const gui = new GUI(),
					props = {
						alphaToCoverage: true,
                        showHelpers: false,
					},
					folderLocal = gui.addFolder("Local Clipping"),
					propsLocal = {
						get Enabled() {
							return renderer.localClippingEnabled;
						},
						set Enabled(v) {
							renderer.localClippingEnabled = v;
						},

						get Shadows() {
							return material.clipShadows;
						},
						set Shadows(v) {
							material.clipShadows = v;
						},

                        // Cube Planes setter and getter
						get Plane1() {
							return planes[0].constant;
						},
						set Plane1(v) {
							planes[0].constant = v;
						},

                        get Plane2() {
							return planes[1].constant;
						},
						set Plane2(v) {
							planes[1].constant = v;
						},

                        get Plane3() {
							return planes[2].constant;
						},
						set Plane3(v) {
							planes[2].constant = v;
						},

                        get Plane4() {
							return planes[3].constant;
						},
						set Plane4(v) {
							planes[3].constant = v;
						},

                        get Plane5() {
							return planes[4].constant;
						},
						set Plane5(v) {
							planes[4].constant = v;
						},

                        get Plane6() {
							return planes[5].constant;
						},
						set Plane6(v) {
							planes[5].constant = v;
						},


                        // TorusKnot Object Position
                        get GeoX() {
							return object.position.x;
						},
						set GeoX(v) {
							object.position.x = v;
						},

                        get GeoY() {
							return object.position.y;
						},
						set GeoY(v) {
							object.position.y = v;
						},

                        get GeoZ() {
							return object.position.z;
						},
						set GeoZ(v) {
							object.position.z = v;
						},
					},

                    showHelpersFolder = gui.add( props, 'showHelpers' ).name( 'show helpers' ).onChange( function ( value ) {
                        helpers.visible = value;
                        // render();
                    } );
                    
					// folderGlobal = gui.addFolder("Global Clipping"),
					// propsGlobal = {
					// 	get Enabled() {
					// 		return renderer.clippingPlanes !== Empty;
					// 	},
					// 	set Enabled(v) {
					// 		renderer.clippingPlanes = v ? globalPlanes : Empty;
					// 	},

					// 	get Plane() {
					// 		return globalPlane.constant;
					// 	},
					// 	set Plane(v) {
					// 		globalPlane.constant = v;
					// 	},
					// };

				// gui.add(props, "alphaToCoverage").onChange(function (value) {
				// 	ground.material.alphaToCoverage = value;
				// 	ground.material.needsUpdate = true;

				// 	material.alphaToCoverage = value;
				// 	material.needsUpdate = true;
				// });
				// folderLocal.add(propsLocal, "Shadows");
				folderLocal.add(propsLocal, "Enabled");

                // Cube Planes
				folderLocal.add(propsLocal, "Plane1", -3, 3, 0.01);
				folderLocal.add(propsLocal, "Plane2", -3, 3, 0.01);
				folderLocal.add(propsLocal, "Plane3", -3, 3, 0.01);
				folderLocal.add(propsLocal, "Plane4", -3, 3, 0.01);
				folderLocal.add(propsLocal, "Plane5", -3, 3, 0.01);
				folderLocal.add(propsLocal, "Plane6", -3, 3, 0.01);

                // TorusKnot Object Positions
				folderLocal.add(propsLocal, "GeoX", -2, 2, 0.1);
				folderLocal.add(propsLocal, "GeoY", -2, 2, 0.1);
				folderLocal.add(propsLocal, "GeoZ", -2, 2, 0.1);
                

				// folderGlobal.add(propsGlobal, "Enabled");
				// folderGlobal.add(propsGlobal, "Plane", -0.4, 3);

				// Start
				startTime = Date.now();

                // Raycaster
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                window.addEventListener('click', (e) => onClick(e, planes), false);
			
            }

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

            function onClick(event, planes) {
                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Update the raycaster with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);

                // Calculate objects intersecting the ray
                const intersects = raycaster.intersectObject(object);

                if (intersects.length > 0) {
                    const interObj = intersects[0];
                    var isClickedInsideClippedVolume = (
                                    planes[0].distanceToPoint(interObj.point) > 0 &&
                                    planes[1].distanceToPoint(interObj.point) > 0 &&
                                    planes[2].distanceToPoint(interObj.point) > 0 &&
                                    planes[3].distanceToPoint(interObj.point) > 0 &&
                                    planes[4].distanceToPoint(interObj.point) > 0 &&
                                    planes[5].distanceToPoint(interObj.point) > 0 
                                );
                    // console.log("isClickedInsideClippedVolume: ", 
                    //                 planes[0].distanceToPoint(interObj.point),
                    //                 planes[1].distanceToPoint(interObj.point),
                    //                 planes[2].distanceToPoint(interObj.point),
                    //                 planes[3].distanceToPoint(interObj.point),
                    //                 planes[4].distanceToPoint(interObj.point),
                    //                 planes[5].distanceToPoint(interObj.point),
                    //             );

                    if(isClickedInsideClippedVolume){
                        alert("****************** TorusKnot Clicked! ******************");
                        console.log("****** TorusKnot Clicked! ******");
                    }
                }
            }

			function animate() {
				const currentTime = Date.now();
				const time = (currentTime - startTime) / 1000;

				requestAnimationFrame(animate);

				// object.position.y = -0.5;
				// object.position.x = -0.5;
				// object.rotation.x = time * 0.5;
				// object.rotation.y = time * 0.2;
				// object.scale.setScalar(Math.cos(time) * 0.125 + 1);

				stats.begin();
				renderer.render(scene, camera);
				stats.end();
			}
		</script>
	</body>
</html>


